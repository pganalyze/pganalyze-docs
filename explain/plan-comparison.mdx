---
title: 'EXPLAIN plan comparison'
backlink_href: /docs/explain/
backlink_title: 'Documentation: EXPLAIN - Overview'
---

import explainComparison from './explain-comparison.png'

export const ImgExplainComparison = () => <img src={explainComparison} alt="Explain comparison example" />

In the course of analyzing query performance, you will typically need to compare
EXPLAIN plans at some point. Conceptually, one can either focus on either the
overall plan shape or on the differences in execution metrics across matching
nodes in two different plans.


## Comparison basics

Generally speaking, there are no "good plans" and "bad plans" in Postgres. There
are only plans that may be more or less appropriate for a given query. A
sequential scan is more efficient and faster than an index scan when most of the
data in a table is required to answer a query.

To compare two plans, it's important to understand why Postgres chooses a
certain plan (which comes down to costs) and what alternate options are
available.


## Plan shape

Plans can vary significantly across different executions of the same query. The
most impactful differences are generally in the [scan
nodes](/docs/explain/scan-nodes) and [join nodes](/docs/explain/join-nodes)
selected for the plan. If you're trying to understand performance differences
between plans, it's best to start with those nodes.


## Plan metrics

EXPLAIN plans, especially ones gathered with the `BUFFERS` option, can be compared on
a number of different metrics. Different metrics give different insights into
the plans being compared:

 - Cost: the cost to execute this node, as estimated by the planner
 - Runtime: the total time it took to execute this node
 - I/O Time: the total time this node spent performing I/O (requires `track_io_timing` on)
 - Rows: the total rows returned by this node
 - Buffers: the total number of pages read from either disk or the OS page cache (read) or found in [`shared_buffers`](https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-SHARED-BUFFERS) (requires the `BUFFERS` option)

All these metrics include the cumulative values from child nodes (except row
counts) in standard EXPLAIN output.


### Cost

This is a useful metric to understand the planner's "reasoning" for choosing
what may be an inefficient plan. The planner determines cost based on statistics
about the selectivity of query filters, information about the table, its data, and its indexes gathered by
[ANALYZE](https://www.postgresql.org/docs/17/sql-analyze.html) (both manual and
through autovacuum); [extended
statistics](https://www.postgresql.org/docs/current/sql-createstatistics.html);
planner [configuration
settings](https://www.postgresql.org/docs/current/runtime-config-query.html#RUNTIME-CONFIG-QUERY);
and derived estimates and heuristics.


### Runtime

The execution time of the plan node, or the overall query. Note this excludes planning time, as well as time spent waiting for locks. This is usually the most relevant metric overall: this determines query latency,
and is ultimately what you will be trying to optimize.


### I/O Time

The running time of expensive queries that read a lot of data from disk is
usually I/O bound. Given the limited memory usage accounting available (see the
[Buffers](#buffers) section), actual time spent doing I/O is a good proxy for
buffers read.


If some data is cached, this can be an unreliable metric, but if you can perform
a cold-cache test, and you expect the query to often run with at least partially
uncached data, this can be very informative.

To run a cold cache test, you'll need to restart Postgres and clear the OS page
cache (see, e.g., [these instructions for
Linux](https://www.kernel.org/doc/html/latest/admin-guide/sysctl/vm.html#drop-caches)).


### Rows

Varying row count estimates are one of the big reasons for plan changes. Look at
rows to understand what may be driving the cost differences that lead to
different plans.


### Buffers

Since I/O timing can be unreliabe, but memory usage can still be very important,
buffer usage can be a good proxy for actual memory usage of your query.
Unfortunately, the EXPLAIN
[BUFFERS](https://www.postgresql.org/docs/current/sql-explain.html) option does
not count unique buffer accesses: it counts the total number of accesses.
Queries that read the same pages of data over and over (e.g., ones involving
[nested loop joins](join-nodes/nested-loop)) can end up over-counting buffer
usage.


## Plan Comparison in pganalyze

In the pganalyze Plan Comparison view, we simplify comparing EXPLAIN plans by showing a diff-like
view of the two different plan shapes, as well as comparing metrics for each plan node:

<ImgExplainComparison />
<br />

A summary of both plans is available in the sidebar on the right. Below the
summary, there's a comparison of the index usage of these plans: all indexes
used by either plan are listed, with a checkmark in the A column if the index is
used by the first plan, and a checkmark in the B column if the index is used by
the second plan. In the main plan diff view, indexes are referenced by footnote.

Nodes that scan tables, views, or set-returning functions include the table,
view, or function name next to the node name in a lighter color. It may be
truncated, but you can hover over the node to see the full name.

Subplans that are essentially executed separately in Postgres are split out into
a separate section of the diff, below the main plan. Plan nodes that scan these
subplans include the subplan name next to the plan node, just like table scans.

Clicking on a node in the diff view in either plan A or plan B will update the
sidebar to show the details for that plan node. You can click Node Source to
view the full JSON source for that node.

You can select a comparison metric at the top to see per-node comparisons
according to that metric: all the metrics described [above](#plan-metrics) are
supported.

Note that the Buffers metric is a combination of shared and local buffers hit
and read. It does not count buffers written or dirtied, and it does not count
temp buffers (e.g., used for a sort that spills to disk).